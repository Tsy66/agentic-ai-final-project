import * as GeminiService from './geminiService';
import { AgentType, AgentMessage, SharedAgentState, Language } from '../types';

// Abstract Base Class for an Autonomous Agent
abstract class BaseAgent {
  id: string;
  name: AgentType;

  constructor(id: string, name: AgentType) {
    this.id = id;
    this.name = name;
  }

  // The core logic: Should I act based on the last message?
  // Returns a Promise of a new message if acted, or null if ignored.
  abstract process(
    lastMessage: AgentMessage, 
    sharedState: SharedAgentState,
    language: Language
  ): Promise<AgentMessage | null>;
}

// --- 1. Risk Agent ---
export class RiskAgent extends BaseAgent {
  constructor() { super('risk', 'RISK_AGENT'); }

  async process(msg: AgentMessage, state: SharedAgentState, lang: Language): Promise<AgentMessage | null> {
    // Trigger: When System says START.
    if (msg.from === 'SYSTEM' && msg.type === 'TASK_START' && state.userInputs) {
      
      const result = await GeminiService.runRiskAnalysisAgent(state.userInputs.answers, lang);
      
      return {
        id: crypto.randomUUID(),
        from: this.name,
        to: 'ALL',
        type: 'DATA_SHARED',
        content: `I have analyzed the user's risk profile. Level: ${result.level} (Score: ${result.score}).`,
        data: { riskResult: result },
        timestamp: Date.now()
      };
    }
    return null;
  }
}

// --- 2. Market Agent ---
export class MarketAgent extends BaseAgent {
  constructor() { super('market', 'MARKET_AGENT'); }

  async process(msg: AgentMessage, state: SharedAgentState, lang: Language): Promise<AgentMessage | null> {
    // PARALLEL OPTIMIZATION: 
    // Trigger on TASK_START, same as Risk Agent. Don't wait for Risk Agent.
    if (msg.from === 'SYSTEM' && msg.type === 'TASK_START' && state.userInputs) {
      
      const marketPref = state.userInputs.market;
      const marketContext = await GeminiService.runMarketDataAgent(marketPref, lang);

      return {
        id: crypto.randomUUID(),
        from: this.name,
        to: 'PORTFOLIO_AGENT', 
        type: 'DATA_SHARED',
        content: `I have retrieved real-time data for ${marketPref.toUpperCase()} markets.`,
        data: { marketContext },
        timestamp: Date.now()
      };
    }
    return null;
  }
}

// --- 3. Portfolio Agent ---
export class PortfolioAgent extends BaseAgent {
  constructor() { super('portfolio', 'PORTFOLIO_AGENT'); }

  async process(msg: AgentMessage, state: SharedAgentState, lang: Language): Promise<AgentMessage | null> {
    // Intelligent Trigger:
    // I listen for DATA_SHARED messages from EITHER Risk or Market agents.
    // But I only proceed if I have BOTH pieces of data on the blackboard.
    
    const isRelevantMsg = (msg.from === 'RISK_AGENT' || msg.from === 'MARKET_AGENT') && msg.type === 'DATA_SHARED';
    
    if (isRelevantMsg) {
      // CHECK BLACKBOARD: Do we have everything?
      if (!state.riskResult || !state.marketContext || !state.userInputs) {
        // Not ready yet, waiting for the other agent to finish.
        return null;
      }

      // GUARD: Have we already generated portfolios? If so, don't do it again.
      // (Because both Risk and Market finishing will trigger this check twice)
      if (state.portfolios && state.portfolios.length > 0) {
        return null; 
      }

      const defaultPrefs = `Market Focus: ${state.userInputs.market.toUpperCase()}. Auto-generated by system based on risk profile.`;
      
      const portfolios = await GeminiService.runPortfolioDesignAgent(
        state.riskResult,
        state.userInputs.market,
        defaultPrefs,
        state.marketContext,
        lang
      );

      return {
        id: crypto.randomUUID(),
        from: this.name,
        to: 'SIMULATION_AGENT',
        type: 'DATA_SHARED',
        content: `I have designed ${portfolios.length} portfolio strategies based on Risk Level ${state.riskResult.level} and Market Data.`,
        data: { portfolios },
        timestamp: Date.now()
      };
    }
    return null;
  }
}

// --- 4. Simulation Agent ---
export class SimulationAgent extends BaseAgent {
  constructor() { super('simulation', 'SIMULATION_AGENT'); }

  async process(msg: AgentMessage, state: SharedAgentState, lang: Language): Promise<AgentMessage | null> {
    // Trigger: When Portfolio is ready
    if (msg.from === 'PORTFOLIO_AGENT' && msg.type === 'DATA_SHARED') {
      
      if (!state.portfolios || state.portfolios.length === 0) return null;

      // Simulate the first (recommended) portfolio
      const simulationData = await GeminiService.runSimulationAgent(state.portfolios[0], 10);

      return {
        id: crypto.randomUUID(),
        from: this.name,
        to: 'REPORT_AGENT',
        type: 'DATA_SHARED',
        content: "Monte Carlo Simulation complete (10 years projected). Stress tests included.",
        data: { simulationData },
        timestamp: Date.now()
      };
    }
    return null;
  }
}

// --- 5. Report Agent ---
export class ReportAgent extends BaseAgent {
  constructor() { super('report', 'REPORT_AGENT'); }

  async process(msg: AgentMessage, state: SharedAgentState, lang: Language): Promise<AgentMessage | null> {
    // Trigger: When Simulation is done
    if (msg.from === 'SIMULATION_AGENT' && msg.type === 'DATA_SHARED') {
      
      if (!state.riskResult || !state.portfolios || !state.simulationData) return null;

      const report = await GeminiService.runReportAgent(
        state.riskResult,
        state.portfolios,
        state.simulationData,
        state.marketContext || "N/A",
        lang
      );

      return {
        id: crypto.randomUUID(),
        from: this.name,
        to: 'SYSTEM',
        type: 'TASK_COMPLETED',
        content: "Final Investment Report generated and ready for user review.",
        data: { report },
        timestamp: Date.now()
      };
    }
    return null;
  }
}